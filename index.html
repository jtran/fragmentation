<!doctype html>
<html lang="en">
<head>
<title>The Grid</title>
<style type="text/css">
html {
background-color: #000;
}
#field {
height: 400px; width: 200px; margin: 10px auto;
position: relative;
background-color: #0E2F38;
}
.block {
padding: 2px;
height: 14px; width: 14px;
position: absolute;
/*-webkit-transition: left 0.1s ease-out, top 0.1s ease-out;*/
}
.light {
background-color: #fff;
box-shadow: 0 0 15px #0AD8FF;
}
.dark {
background-color: #000;
box-shadow: 0 0 15px #0AD8FF;
}
#tail {
position: absolute;
opacity: 0.9;
background-color: #fff;
box-shadow: 0 0 15px #0AD8FF;
border-top-left-radius: 8px;
border-top-right-radius: 8px;
}
</style>
<!-- <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script> -->
<script type="text/javascript" src="jquery.min.js"></script>
<script type="text/javascript" src="jquery-ui.custom.min.js"></script>
<script type="text/javascript" src="underscore.js"></script>
<script type="text/javascript">//<![CDATA[
var fieldHeight = 20;
var fieldWidth = 10;
var blockHeight = 20;
var blockWidth = 20;
var borderWidth = 1;
var borderHeight = 1;
var blocks = [];
var NUM_TYPES_OF_BLOCKS = 7;

// Return random integer in interval [0...n].
function randInt(n) {
  return Math.floor(Math.random() * (n+1));
}

function FloatingBlock() {
  this.type = randInt(NUM_TYPES_OF_BLOCKS - 1);
  this.canRotate = true;
  this.elms = $.map([0,1,2,3], function() {
    var e = document.createElement('div');
    e.className = 'block';
    return e;
  });
  var mid = Math.floor(fieldWidth / 2) - 1;
  switch (this.type) {
  case 0:  // O
    setXy(this.elms[0], [mid,     0]);
    setXy(this.elms[1], [mid + 1, 0]);
    setXy(this.elms[2], [mid,     1]);
    setXy(this.elms[3], [mid + 1, 1]);
    this.centerIndex = 0;
    this.canRotate = false;
    $(this.elms).addClass('light');
    break;
  case 1:  // T
    setXy(this.elms[0], [mid - 1, 0]);
    setXy(this.elms[1], [mid,     0]);
    setXy(this.elms[2], [mid + 1, 0]);
    setXy(this.elms[3], [mid,     1]);
    this.centerIndex = 1;
    $(this.elms).addClass('light');
    break;
  case 2:  // S
    setXy(this.elms[0], [mid + 1, 0]);
    setXy(this.elms[1], [mid,     0]);
    setXy(this.elms[2], [mid,     1]);
    setXy(this.elms[3], [mid - 1, 1]);
    this.centerIndex = 2;
    $(this.elms).addClass('dark');
    break;
  case 3:  // Z
    setXy(this.elms[0], [mid - 1, 0]);
    setXy(this.elms[1], [mid,     0]);
    setXy(this.elms[2], [mid,     1]);
    setXy(this.elms[3], [mid + 1, 1]);
    this.centerIndex = 2;
    $(this.elms).addClass('dark');
    break;
  case 4:  // L
    setXy(this.elms[0], [mid - 1, 0]);
    setXy(this.elms[1], [mid,     0]);
    setXy(this.elms[2], [mid + 1, 0]);
    setXy(this.elms[3], [mid - 1, 1]);
    this.centerIndex = 1;
    $(this.elms).addClass('dark');
    break;
  case 5:  // J
    setXy(this.elms[0], [mid - 1, 0]);
    setXy(this.elms[1], [mid,     0]);
    setXy(this.elms[2], [mid + 1, 0]);
    setXy(this.elms[3], [mid + 1, 1]);
    this.centerIndex = 1;
    $(this.elms).addClass('dark');
    break;
  case 6:  // I
    setXy(this.elms[0], [mid - 1, 0]);
    setXy(this.elms[1], [mid,     0]);
    setXy(this.elms[2], [mid + 1, 0]);
    setXy(this.elms[3], [mid + 2, 0]);
    this.centerIndex = 1;
    $(this.elms).addClass('light');
    break;
  default:
    throw "I don't know how to create a floating block of this type: " + this.type;
  }
}

FloatingBlock.prototype.rotateClockwise = function() {
  if (! this.canRotate) return false;
  var xyCenter = xyOf(this.elms[this.centerIndex]);
  var xys2 = _(this.elms).map(function(e) {
    var xy = xyOf(e);
    var dx = xy[0] - xyCenter[0];
    var dy = xy[1] - xyCenter[1];
    return [xyCenter[0] - dy, xyCenter[1] + dx];
  });
  if (_(xys2).some(isXyTaken)) return false;
  $.each(this.elms, function(i, e) {
    setXy(e, xys2[i]);
  });
  return true;
}

FloatingBlock.prototype.rotateCounterclockwise = function() {
  if (! this.canRotate) return false;
  var xyCenter = xyOf(this.elms[this.centerIndex]);
  var xys2 = _(this.elms).map(function(e) {
    var xy = xyOf(e);
    var dx = xy[0] - xyCenter[0];
    var dy = xy[1] - xyCenter[1];
    return [xyCenter[0] + dy, xyCenter[1] - dx];
  });
  if (_(xys2).some(isXyTaken)) return false;
  $.each(this.elms, function(i, e) {
    setXy(e, xys2[i]);
  });
  return true;
}

function setPosition(sel, left, top) {
  $(sel).css({'left': left + 'px', 'top': top + 'px'});
}

function setXy(sel, xy) {
  setPosition(sel, xy[0] * blockWidth, xy[1] * blockHeight);
}

function xyOf(selector) {
  var pos = $(selector).position();
  return [Math.floor(pos.left / blockWidth), Math.floor(pos.top / blockHeight)];
}

function blockFromXy(xy) {
  var row = xy[1];
  if (row < 0 || row >= blocks.length) return null;
  var col = xy[0];
  if (col < 0 || col >= blocks[row].length) return null;
  return blocks[row][col];
}

function storeBlock(blk, xy) {
  blocks[xy[1]][xy[0]] = blk;
}

function ltFromXy(xy) {
  return [xy[0] * blockWidth, xy[1] * blockHeight];
}

function isXyFree(xy) {
  return blockFromXy(xy) === null &&
    xy[0] >= 0 && xy[0] < fieldWidth &&
    xy[1] >= 0 && xy[1] < fieldHeight;
}

function isXyTaken(xy) {
  return ! isXyFree(xy);
}

function moveLeft() {
  xys2 = _.map(curFloating.elms, function(e) {
    var xy = xyOf(e);
    return [xy[0] - 1, xy[1]];
  });
  if (_(xys2).some(isXyTaken)) return false;
  $.each(curFloating.elms, function(i, e) {
    var lt = ltFromXy(xys2[i]);
    setPosition(e, lt[0], lt[1]);
  });
  return true;
}

function moveRight() {
  xys2 = _.map(curFloating.elms, function(e) {
    var xy = xyOf(e);
    return [xy[0] + 1, xy[1]];
  });
  if (_(xys2).some(isXyTaken)) return false;
  $.each(curFloating.elms, function(i, e) {
    var lt = ltFromXy(xys2[i]);
    setPosition(e, lt[0], lt[1]);
  });
  return true;
}

function moveDown() {
  xys2 = _.map(curFloating.elms, function(e) {
    var xy = xyOf(e);
    return [xy[0], xy[1] + 1];
  });
  if (_(xys2).some(isXyTaken)) return false;
  $.each(curFloating.elms, function(i, e) {
    var lt = ltFromXy(xys2[i]);
    setPosition(e, lt[0], lt[1]);
  });
  return true;
}

function landFloatingBlock(blk) {
  _.each(blk.elms, function(e) {
    storeBlock(e, xyOf(e));
  });
}

// Returns array of y's of lines that need to be cleared.
function linesToClear(flt) {
  var linesToCheck = _(flt.elms).chain()
    .map(function(e) { return xyOf(e)[1] }).uniq().value();
  var linesToClear = _(linesToCheck).select(function(y) {
    return _(blocks[y]).all(_.identity);
  });
  return linesToClear;
}

function fillLinesFromAbove(ys) {
  if (_.isEmpty(ys)) return;
  var shift = 1;
  ys.sort();
  for (var y = _.last(ys); y >= 0; y--) {
    while (_.include(ys, y - shift)) shift++;
    for (var x = 0; x < fieldWidth; x++) {
      var blk = blockFromXy([x, y - shift]);
      if (blk) setXy(blk, [x, y]);
      storeBlock(blk, [x, y]);
    }
  }
}

function clearLine(y) {
  for (var x = 0; x < fieldWidth; x++) {
    var blk = blocks[y][x];
    $(blk).remove();
    storeBlock(null, [x, y]);
  }
}

function clearLines(ys) {
  _(ys).each(clearLine);
}

function showNewFloatingBlock() {
  curFloating = new FloatingBlock();
  $(curFloating.elms).appendTo('#field');
}

// Returns true if game is over.
function checkForGameOver() {
  if (_(curFloating.elms).chain().map(xyOf).some(isXyTaken).value()) {
    window.clearInterval(fallTimer);
    fallTimer = null;
    return true;
  }
  return false;
}

function fall() {
  var fell = moveDown();
  if (! fell) {
    landFloatingBlock(curFloating);
    var ysToClear = linesToClear(curFloating);
    var clearedLines = ysToClear.length > 0;
    if (clearedLines) {
      // Lines were cleared.  Pause the game timer.
      window.clearInterval(fallTimer);
      fallTimer = null;
    }
    showNewFloatingBlock();
    clearLines(ysToClear);
    if (clearedLines) {
      _.delay(function() {
        fillLinesFromAbove(ysToClear);
        if (! checkForGameOver()) {
          fallTimer = window.setInterval(fall, 700);
        }
      }, 500);
    }
    else {
      if (checkForGameOver()) return false;
    }
  }
  return fell;
}

function drop() {
  // Get initial position.
  var floating = curFloating;
  var xys = _(floating.elms).map(xyOf);
  var minX1 = _(xys).chain().map(function(xy) { return xy[0] }).min().value();
  var minY1 = _(xys).chain().map(function(xy) { return xy[1] }).min().value();

  // Drop.
  while (fall()) ;

  // Set position and size of tail.
  var xys2 = _(floating.elms).map(xyOf);
  setXy('#tail', [minX1, minY1]);

  var minX = _(xys).chain()
    .map(function(xy) { return xy[0] }).min().value();
  var maxX = _(xys2).chain()
    .map(function(xy) { return xy[0] }).max().value();
  var minY = _(xys).chain()
    .map(function(xy) { return xy[1] }).min().value();
  var maxY = _(xys2).chain()
    .map(function(xy) { return xy[1] }).min().value();
  $('#tail').width(blockWidth * (maxX - minX + 1) - 2 * borderWidth).height(blockHeight * (maxY - minY + 1) - 2 * borderHeight);

  // Show tail and hide after delay.
  $('#tail').show();
  window.setTimeout(function() {
    $e = $('#tail');
    $e.animate({'height': 0, 'top': $e.position().top + $e.height()}, 500, 'easeOutExpo');
  }, 500);
}

var curFloating;
var fallTimer;

$(function() {
  for (var i = 0; i < fieldHeight; i++) {
    var row = [];
    for (var j = 0; j < fieldWidth; j++) { row.push(null); }
    blocks.push(row);
  }
  showNewFloatingBlock();

  $(document).bind('keydown', function(event) {
//    console.log('keydown', event.which, String.fromCharCode(event.which));
    if (event.which == 37)  moveLeft();
    if (event.which == 39)  moveRight();
    if (event.which == 40)  fall();
    if (event.which == 191) drop(); // slash
    var letter = String.fromCharCode(event.which).toLowerCase();
    if (letter == 'f') curFloating.rotateClockwise();
    if (letter == 'd') curFloating.rotateCounterclockwise();
    if (letter == 'c') drop();
  });

  fallTimer = window.setInterval(fall, 700);
});
//]]></script>
</head>
<body>


<div id="background">
  <div id="field">
    <div id="tail"></div>
  </div>
</div>

</body>
</html>
