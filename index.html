<!doctype html>
<html lang="en">
<head>
<title>The Grid</title>
<style type="text/css">
html {
background-color: #000;
}
#field {
height: 442px; width: 202px; margin: 10px auto;
position: relative;
}
#field_background {
width: 100%; height: 402px;
position: relative; top: 40px;
background-color: #0E2F38;
}
.block {
padding: 2px;
height: 14px; width: 14px;
position: absolute;
-webkit-transition: left 0.1s ease-out, top 0.1s ease-out, opacity 0.1s ease-out;
-moz-transition: left 0.1s ease-out, top 0.1s ease-out, opacity 0.1s ease-out;
}
.light {
background-color: #fff;
}
.dark {
background-color: #000;
}
.block.blue {
box-shadow: 0 0 15px #0AD8FF;
}
.block.orange {
box-shadow: 0 0 15px #FF9D02;
}
#tail {
position: absolute;
opacity: 0.9;
background-color: #fff;
border-top-left-radius: 8px;
border-top-right-radius: 8px;
}
#tail.blue {
box-shadow: 0 0 15px #0AD8FF;
}
#tail.orange {
box-shadow: 0 0 15px #FF9D02;
}
.next {
opacity: 0.7;
}
</style>
<!-- <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script> -->
<script type="text/javascript" src="jquery.min.js"></script>
<script type="text/javascript" src="jquery-ui.custom.min.js"></script>
<script type="text/javascript" src="underscore.js"></script>
<script type="text/javascript">//<![CDATA[
var fieldHeight = 22;
var fieldWidth = 10;
var blockHeight = 20;
var blockWidth = 20;
var borderWidth = 1;
var borderHeight = 1;
var blocks = [];
var NUM_TYPES_OF_BLOCKS = 7;

var curFloating;
var nextFloating;
var fallTimer;


// Return random integer in interval [0...n].
function randInt(n) {
  return Math.floor(Math.random() * (n+1));
}

// Represents a single square.
function Block(x, y) {
  this.x = x;
  this.y = y;
  this.elm = document.createElement('div');
  this.elm.className = 'block next';
  this.setXy([x, y]);
}

Block.prototype.setXy = function(xy) {
  this.x = xy[0];
  this.y = xy[1];
  setElementXy(this.elm, xy);
}

Block.prototype.getXy = function() {
  return [this.x, this.y];
}

function FloatingBlock() {
  this.type = randInt(NUM_TYPES_OF_BLOCKS - 1);
  this.canRotate = true;
  this.blocks = [];
  var mid = Math.floor(fieldWidth / 2) - 1;
  switch (this.type) {
  case 0:  // O
    this.blocks.push(new Block(mid,     0));
    this.blocks.push(new Block(mid + 1, 0));
    this.blocks.push(new Block(mid,     1));
    this.blocks.push(new Block(mid + 1, 1));
    this.centerIndex = 0;
    this.canRotate = false;
    $(this.elms()).addClass('light');
    break;
  case 1:  // T
    this.blocks.push(new Block(mid - 1, 0));
    this.blocks.push(new Block(mid,     0));
    this.blocks.push(new Block(mid + 1, 0));
    this.blocks.push(new Block(mid,     1));
    this.centerIndex = 1;
    $(this.elms()).addClass('light');
    break;
  case 2:  // S
    this.blocks.push(new Block(mid + 1, 0));
    this.blocks.push(new Block(mid,     0));
    this.blocks.push(new Block(mid,     1));
    this.blocks.push(new Block(mid - 1, 1));
    this.centerIndex = 2;
    $(this.elms()).addClass('dark');
    break;
  case 3:  // Z
    this.blocks.push(new Block(mid - 1, 0));
    this.blocks.push(new Block(mid,     0));
    this.blocks.push(new Block(mid,     1));
    this.blocks.push(new Block(mid + 1, 1));
    this.centerIndex = 2;
    $(this.elms()).addClass('dark');
    break;
  case 4:  // L
    this.blocks.push(new Block(mid - 1, 0));
    this.blocks.push(new Block(mid,     0));
    this.blocks.push(new Block(mid + 1, 0));
    this.blocks.push(new Block(mid - 1, 1));
    this.centerIndex = 1;
    $(this.elms()).addClass('dark');
    break;
  case 5:  // J
    this.blocks.push(new Block(mid - 1, 0));
    this.blocks.push(new Block(mid,     0));
    this.blocks.push(new Block(mid + 1, 0));
    this.blocks.push(new Block(mid + 1, 1));
    this.centerIndex = 1;
    $(this.elms()).addClass('dark');
    break;
  case 6:  // I
    this.blocks.push(new Block(mid - 1, 0));
    this.blocks.push(new Block(mid,     0));
    this.blocks.push(new Block(mid + 1, 0));
    this.blocks.push(new Block(mid + 2, 0));
    this.centerIndex = 1;
    $(this.elms()).addClass('light');
    break;
  default:
    throw "I don't know how to create a floating block of this type: " + this.type;
  }
  // Set the theme.
  $(this.elms()).addClass('blue');
  $('#tail').addClass('blue');
//  $(this.elms()).addClass('orange');
//  $('#tail').addClass('orange');
}

FloatingBlock.prototype.elms = function() {
  return _(this.blocks).map(function(blk) { return blk.elm });
}

// Takes a function that takes single argument the Block to be
// transformed, which returns the Block's new xy.  Returns true if the
// transformation was possible.
FloatingBlock.prototype.transform = function(f) {
  var xys2 = _(this.blocks).map(f);
  if (_(xys2).some(isXyTaken)) return false;
  _.each(this.blocks, function(blk, i) {
    blk.setXy(xys2[i]);
  });
  return true;
}

FloatingBlock.prototype.rotateClockwise = function() {
  if (! this.canRotate) return false;
  var xyCenter = this.blocks[this.centerIndex].getXy();
  var rotateWithShift = function(shift) {
    return function(blk) {
      var xy = blk.getXy();
      var dx = xy[0] - xyCenter[0];
      var dy = xy[1] - xyCenter[1];
      return [xyCenter[0] - dy + shift, xyCenter[1] + dx];
    };
  };
  return this.transform(rotateWithShift(0)) ||
    this.transform(rotateWithShift(1)) ||
    this.transform(rotateWithShift(-1));
}

FloatingBlock.prototype.rotateCounterclockwise = function() {
  if (! this.canRotate) return false;
  var xyCenter = this.blocks[this.centerIndex].getXy();
  var rotateWithShift = function(shift) {
    return function(blk) {
      var xy = blk.getXy()
      var dx = xy[0] - xyCenter[0];
      var dy = xy[1] - xyCenter[1];
      return [xyCenter[0] + dy + shift, xyCenter[1] - dx];
    };
  };
  return this.transform(rotateWithShift(0)) ||
    this.transform(rotateWithShift(1)) ||
    this.transform(rotateWithShift(-1));
}

function setPosition(sel, left, top) {
  $(sel).css({'left': left + 'px', 'top': top + 'px'});
}

function setElementXy(sel, xy) {
  setPosition(sel,
              2 * borderWidth  + xy[0] * blockWidth,
              2 * borderHeight + xy[1] * blockHeight);
}

function xyOf(blk) {
  return blk.getXy();
}

function blockFromXy(xy) {
  var row = xy[1];
  if (row < 0 || row >= blocks.length) return null;
  var col = xy[0];
  if (col < 0 || col >= blocks[row].length) return null;
  return blocks[row][col];
}

function storeBlock(blk, xy) {
  blocks[xy[1]][xy[0]] = blk;
}

function isXyFree(xy) {
  return blockFromXy(xy) === null &&
    xy[0] >= 0 && xy[0] < fieldWidth &&
    xy[1] >= 0 && xy[1] < fieldHeight;
}

function isXyTaken(xy) {
  return ! isXyFree(xy);
}

function moveLeft() {
  return curFloating.transform(function(blk) {
    var xy = blk.getXy();
    return [xy[0] - 1, xy[1]];
  });
}

function moveRight() {
  return curFloating.transform(function(blk) {
    var xy = blk.getXy();
    return [xy[0] + 1, xy[1]];
  });
}

function moveDown() {
  return curFloating.transform(function(blk) {
    var xy = blk.getXy();
    return [xy[0], xy[1] + 1];
  });
}

function landFloatingBlock(flt) {
  _.each(flt.blocks, function(blk) {
    storeBlock(blk, blk.getXy());
  });
}

// Returns array of y's of lines that need to be cleared.
function linesToClear(flt) {
  var linesToCheck = _(flt.blocks).chain()
    .map(function(blk) { return blk.getXy()[1] }).uniq().value();
  var linesToClear = _(linesToCheck).select(function(y) {
    return _(blocks[y]).all(_.identity);
  });
  return linesToClear;
}

function fillLinesFromAbove(ys) {
  if (_.isEmpty(ys)) return;
  var shift = 1;
  ys.sort();
  for (var y = _.last(ys); y >= 0; y--) {
    while (_.include(ys, y - shift)) shift++;
    for (var x = 0; x < fieldWidth; x++) {
      var blk = blockFromXy([x, y - shift]);
      if (blk) blk.setXy([x, y]);
      storeBlock(blk, [x, y]);
    }
  }
}

function clearLine(y) {
  for (var x = 0; x < fieldWidth; x++) {
    var blk = blocks[y][x];
    $(blk.elm).remove();
    storeBlock(null, [x, y]);
  }
}

function clearLines(ys) {
  _(ys).each(clearLine);
}

function showNewFloatingBlock() {
  // The first time this is called, next will be null.
  if (! nextFloating) {
    nextFloating = new FloatingBlock();
    $(nextFloating.elms()).appendTo('#field');
  }
  // Make next be current and spawn a new next.
  curFloating = nextFloating;
  nextFloating = new FloatingBlock();
  // Move the new current into position.
  $(curFloating.elms()).removeClass('next');
  _(curFloating.blocks).each(function(blk) { blk.setXy([blk.x, blk.y + 2]) });
  $(nextFloating.elms()).appendTo('#field');
}

// Returns true if game is over.
function checkForGameOver() {
  if (_(curFloating.blocks).chain().map(xyOf).some(isXyTaken).value()) {
    window.clearInterval(fallTimer);
    fallTimer = null;

    var music = $('#music').get(0);
    if (music) music.pause();

    return true;
  }
  return false;
}

function fall() {
  var fell = moveDown();
  if (! fell) {
    landFloatingBlock(curFloating);
    var ysToClear = linesToClear(curFloating);
    var clearedLines = ysToClear.length > 0;
    if (clearedLines) {
      // Lines were cleared.  Pause the game timer.
      window.clearInterval(fallTimer);
      fallTimer = null;
    }
    showNewFloatingBlock();
    clearLines(ysToClear);
    if (clearedLines) {
      _.delay(function() {
        fillLinesFromAbove(ysToClear);
        if (! checkForGameOver()) {
          fallTimer = window.setInterval(fall, 700);
        }
      }, 500);
    }
    else {
      if (checkForGameOver()) return false;
    }
  }
  return fell;
}

function drop() {
  // Get initial position.
  var floating = curFloating;
  var xys = _(floating.blocks).map(xyOf);
  var minX1 = _(xys).chain().map(function(xy) { return xy[0] }).min().value();
  var minY1 = _(xys).chain().map(function(xy) { return xy[1] }).min().value();

  // Drop.
  while (fall()) ;

  // Set position and size of tail.
  var xys2 = _(floating.blocks).map(xyOf);
  setElementXy('#tail', [minX1, minY1]);

  var minX = _(xys).chain()
    .map(function(xy) { return xy[0] }).min().value();
  var maxX = _(xys2).chain()
    .map(function(xy) { return xy[0] }).max().value();
  var minY = _(xys).chain()
    .map(function(xy) { return xy[1] }).min().value();
  var maxY = _(xys2).chain()
    .map(function(xy) { return xy[1] }).min().value();
  $('#tail').width(blockWidth * (maxX - minX + 1) - 2 * borderWidth).height(blockHeight * (maxY - minY + 1) - 2 * borderHeight);

  // Show tail and hide after delay.
  $('#tail').show();
  window.setTimeout(function() {
    $e = $('#tail');
    $e.animate({'height': 0, 'top': $e.position().top + $e.height()}, 500, 'easeOutExpo');
  }, 500);
}

$(function() {
  // Initialize blocks matrix.
  for (var i = 0; i < fieldHeight; i++) {
    var row = [];
    for (var j = 0; j < fieldWidth; j++) { row.push(null); }
    blocks.push(row);
  }
  showNewFloatingBlock();

  $(document).bind('keydown', function(event) {
//    console.log('keydown', event.which, String.fromCharCode(event.which));
    if (event.which == 37)  moveLeft();
    if (event.which == 39)  moveRight();
    if (event.which == 40)  fall();
    if (event.which == 191) drop(); // slash
    var letter = String.fromCharCode(event.which).toLowerCase();
    if (letter == 'f') curFloating.rotateClockwise();
    if (letter == 'd') curFloating.rotateCounterclockwise();
    if (letter == 'c') drop();
  });

  // Play background music if present.
  var music = $('#music').get(0);
  if (music) music.play();

  fallTimer = window.setInterval(fall, 700);
});
//]]></script>
</head>
<body>


<div id="background">
  <div id="field">
    <div id="field_background"></div>
    <div id="tail"></div>
  </div>
</div>

<audio id="music" src="sea-of-simulation.mp3" preload="preload" />

</body>
</html>
